# self-balancing-trees
Exploring the pros/cons, space-time complexity, and usefulness of various self-balancing trees

Lucy, Fremont and Annika hope to engage in the discussion of the pros and cons of different self-balancing trees. In class, we learned how to implement an AVL tree which is a self-balancing tree. We want to build off this implementation by exploring how AVL trees compare to Red Black trees and Scapegoat trees, with regards to time complexity and how challenging each one is to implement/debug. The answers to these sub-questions will assist us in deciding which self-balancing tree to implement in varying applications that need them. We want to look into how time complexities vary between different self-balancing trees to determine which is most time efficient for sorting large amounts of data. We will test time efficiency by counting how many rotations or rebalances the trees do based on the same data set. We will also compare how long it takes each tree to search for an item within the tree using (using the same time library from the HashMap homework). With time complexity in mind, we also want to look into how long each self-balancing tree takes to actually implement. We want to discuss the challenge of implementation because if a self-balancing tree is incredibly efficient yet is very challenging to implement, that is something to consider when deciding what self-balancing tree to use for different applications. Similarly to the challenge of implementation, we want to answer the question of which self-balancing tree is hardest to debug. This differs from our last question because the challenge of implementation takes into account the challenge of learning how to implement the structure and actually turning that into code whereas debugging focuses on the challenges of getting the tree to properly self-balance.
We think that actually engaging in the process of coding up these trees will answer a lot of our questions. We want to do this mostly from scratch--ideally with minimal help from the internet--to truly understand which structures are the hardest to implement and more importantly
 which structures are the hardest to debug. We can quantitatively estimate how challenging it is to implement the trees by comparing how many lines of code it takes. Yet we understand that this would be just an estimate, because the number of lines does not necessarily correlate to the challenge of implementation. We can do this in Jupyter Notebooks. In order to compare run time, we want to use a similar approach to what we did in class. We want to conduct three main experiments. We want to take a large number of samples of each tree’s insert time by inserting various sized lists into each tree structure and counting how many rotations each tree completes. We will compare the rotations done on each tree vs. the size of the list inserted. Additionally we want to take a large number of samples of each tree’s search time by asking the tree to find data of varying sizes within the trees and counting how many recursive search calls each tree makes. We will compare the number of calls on the recursive search method vs the size of the number we are searching for. We will then use matplotlib to plot the results. Finally, we will import the time python library. We will insert various sized lists of nodes gathering how long it takes to insert the list and plot that against the size of the list. This can be accomplished by having a start time variable and a stop time variable and subtracting the stop from start. By considering how difficult these trees are to implement/debug, and by quantitatively comparing run time, we should get some really good insight into which self-balancing tree is the best.
The code artifacts that we would produce with our current plan would be the code to create the Red Black Tree, the AVL tree, and the Scapegoat tree. We would also likely have some test code to run the different trees on, such as a method that randomly gives nodes to be inserted or removed from the different trees. Along with some sort of graph, likely with matplotlib like we have done in class so far, that would compare and contrast the time complexity, memory used, or number of operations. We came to this idea for a project by researching different data structures that fulfilled the same role.
We will divide the work between the three of us by collaborating on the classes and objects of each self-balancing tree but individually implement the operations of the different data

structures. For example, together we would discuss the necessary structure of the class for Red Black trees and Scapegoat trees and write that on each of our devices but Lucy would implement the insert() method for Red Black trees and the insert() method for Scapegoat trees to be able to gauge the difference in challenge of implementation. When we compare our results of time complexity using data samples and graphical plots. We will compare time complexity in one graph. Annika will implement the aesthetic portion of the graph and assist Lucy and Fremont, if needed, in the sub method of creating many samples to test. We will individually summarize our thoughts on the difficulty of the methods we created and then overall decide which implementation was the most challenging and which debugging was most demanding.
We’re hoping that internal python libraries will mostly do the trick for our project so we won’t need to install any external softwares.
